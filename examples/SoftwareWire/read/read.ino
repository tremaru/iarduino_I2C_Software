// ДАННЫЙ ПРИМЕР ЧИТАЕТ ДАННЫЕ ИЗ РЕГИСТОВ МОДУЛЯ ПО ШИНЕ I2C:      // * Строки со звёздочкой являются необязательными.
// Пример "commandSerial" позволяет вводить команды в монитор ПП    //
// для чтения, записи и поиска устройств на шине I2C.               //
                                                                    //
// Данные для чтения (можно менять):                                //
uint8_t adr = 0x09;                                                 //   Адрес модуля на шине I2C.
uint8_t reg = 0x04;                                                 //   Номер регистра с которого требуется начать чтение.
uint8_t sum = 4;                                                    //   Количество читаемых регистров.
                                                                    //
#include <iarduino_I2C_Software.h>                                  //   Подключаем библиотеку для работы с программной шиной I2C, до подключения библиотеки iarduino_I2C_Address.
SoftTwoWire sWire(3,4);                                             //   Создаём объект программной шины I2C указав выводы которым будет назначена роль линий: SDA, SCL.
                                                                    //   Допускается создавать несколько объектов, следовательно, несколько программных шин I2C.
void setup(){                                                       //
     delay(500);                                                    // * Ждём завершение переходных процессов связанных с подачей питания.
     Serial.begin(9600);                                            //   Инициируем передачу данных в монитор последовательного порта на скорости 9600 бит/сек.
     while(!Serial){;}                                              // * Ждём завершения инициализации шины UART.
     sWire.begin();                                                 //   Инициируем работу с программной шиной I2C.
//   sWire.setClock(400000);                                        // * Изменить скорость передачи данных на указанную. По умолчанию скорость 100'000 бит/сек.
//   sWire.setPins(5,6);                                            // * Изменить назначенные ранее выводы шины I2C на указанные: SDA, SCL.
//   sWire.getPins(&sda,&scl);                                      // * Получить действующие выводы шины I2C в переменные: sda, scl.
//   sWire.setWireTimeout(25000);                                   // * Задать таймаут ожидания ведомого в мкс (0 = таймаут отключён). Если вторым параметром указать true, то по достижении таймаута шина будет отключена, как end().
//   sWire.end();                                                   // * Отключение шины. Для включения нужно вновь указать выводы setPins(), а потом begin().
}                                                                   //
                                                                    //
void loop(){                                                        //
     uint8_t i;                                                     //
//   Информируем о адресе модуля и читаемых регистрах:              //
     Serial.print("Адрес модуля 0x"); Serial.print(adr,HEX);        // *
     Serial.print(", регистр 0x");    Serial.print(reg,HEX);        // *
     if( sum>1 ){Serial.print("-0x"); Serial.print(reg+sum-1,HEX);} // *
//   Передаём устройству адрес регистра с которого начнём чтение:   //
     sWire.beginTransmission(adr);                                  //   Инициируем передачу данных по шине I2C к устройству с адресом adr. При этом сама передача не начнётся.
     sWire.write(reg);                                              //   Помещаем в буфер для передачи один байт (адрес первого читаемого регистра).
     i = sWire.endTransmission(false);                              //   Выполняем инициированную ранее передачу данных, без установки STOP. Функция возвращает: 0-успех или 1-5 ошибка (см. ниже).
//   Информируем о ошибке передачи адреса регистра:                 //
     if( i ){                                                       //
         Serial.print( F(" ОШИБКА ПЕРЕДАЧИ АДРЕСА РЕГИСТРА: ") );   //
         if( i==1 ){ Serial.println(F("переполнен буфер"      )); } //   Объем буфера по умолчанию 32 байта. Можно изменить в файле iarduino_I2C_Software.h: #define SOFT_I2C_BUFFER_LENGTH 32
         if( i==2 ){ Serial.println(F("NACK на адреса модуля" )); } //   Модуль не ответил на свой адрес, значит модуля с указанным адресом нет на шине I2C.
         if( i==3 ){ Serial.println(F("NACK на адрес регистра")); } //   Модуль не ответил на получение байта, значит модуль занят, завис или на шине помехи.
         if( i==4 ){ Serial.println(F("неизвестная ошибка"    )); } //
         if( i==5 ){ Serial.println(F("timeout ожидания"      )); } //   Модуль удерживает шину дольше чем указано в setWireTimeout(), по умолчанию 25'000 мкс.
         delay(5000); return;                                       //   Ждём 5 сек и выходим из данного прохода цикла loop().
     }                                                              //
//   Читаем sum байт из модуля adr в буфер библиотеки:              //
     i = sWire.requestFrom( adr, sum );                             //   Читаем (запрашиваем) sum байт данных от устройства с адресом adr. Функция возвращает количество реально принятых байтов.
     Serial.print((String) ", прочитано "+i+" байт:" );             // *
//   Выводим прочитанные данные из буфера:                          //
     while( sWire.available() ){                                    //   Функция available() возвращает количество байт в буфере, доступных для получения функцией read().
         Serial.print(" 0x"); Serial.print( sWire.read(), HEX );    //   Выводим очередной прочитанный байт в шестнадцатиричной системе счисления.
         if( --i ){ Serial.print(','); }                            // * Выводим запятую между байтами.
     }                                                              //
     Serial.println('.');                                           //
//   Задержка перед новым поиском устройств:                        //
     delay(5000);                                                   // * 
}                                                                   //
                                                                    //
/*   Для модулей Flash-I2C и Metro в регистрах 0x4-0x7 хранятся:    //
 *   Регистр 0x04 содержит идентификатор типа модуля.               //
 *   Регистр 0x05 содержит версию прошивки модуля.                  //
 *   Регистр 0x06 содержит адрес модуля сдвинутый на 1 бит влево.   //
 *   Регистр 0x07 содержит 0x3C для Flash-I2C, 0xC3 для Metro.      //
 */