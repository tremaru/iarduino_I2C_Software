// ДАННЫЙ ПРИМЕР ЗАПИСЫВАЕТ ДАННЫЕ В РЕГИСТРЫ МОДУЛЯ ПО ШИНЕ I2C:   // * Строки со звёздочкой являются необязательными.
// Пример "commandSerial" позволяет вводить команды в монитор ПП    //
// для чтения, записи и поиска устройств на шине I2C.               //
                                                                    //
// БУДТЕ ОСТОРОЖНЫ С ДАННЫМ ПРИМЕРОМ!                               //
// Некоторые модули, в т.ч. Flash-I2C и Metro, могут сохранять      //
// записанные данные регистров в энергонезависимую память.          //
                                                                    //
// Данные для записи (можно менять):                                //
uint8_t adr   = 0x09;                                               //   Адрес модуля на шине I2C.
uint8_t reg   = 0x67;                                               //   Номер регистра с которого требуется начать запись.
uint8_t arr[] = {1,2,3,4};                                          //   От 1 до 32 байт для записи в регистры.
                                                                    //
#include <Wire.h>                                                   //   Подключаем библиотеку для работы с аппаратной шиной I2C.
                                                                    //   Далее в примере используется объект Wire для работы с основной аппаратной шиной I2C, но можно использовать объекты Wire1, Wire2 ... если они поддерживаются платой.
void setup(){                                                       //
     delay(500);                                                    // * Ждём завершение переходных процессов связанных с подачей питания.
     Serial.begin(9600);                                            //   Инициируем передачу данных в монитор последовательного порта на скорости 9600 бит/сек.
     while(!Serial){;}                                              // * Ждём завершения инициализации шины UART.
     Wire.begin();                                                  //   Инициируем работу с аппаратной шиной I2C.
//   Wire.setClock(400000);                                         // * Изменить скорость передачи данных на указанную. По умолчанию скорость 100'000 бит/сек.
//   Wire.setPins(5,6);                                             // * Поддерживается не всеми платами. Изменить назначенные ранее выводы шины I2C на указанные: SDA, SCL.
//   Wire.setWireTimeout(25000);                                    // * Поддерживается не всеми платами. Задать таймаут ожидания ведомого в мкс (0 = таймаут отключён). Если вторым параметром указать true, то по достижении таймаута шина будет отключена, как end().
//   Wire.end();                                                    // * Отключение шины. Для включения нужно вновь инициировать шину begin().
}                                                                   //
                                                                    //
void loop(){                                                        //
//   Определяем количество байт в массиве arr:                      //
     uint8_t sum=sizeof(arr);                                       //
//   Информируем о адресе модуля и регистрах для записи:            //
     Serial.print("Адрес модуля 0x"); Serial.print(adr,HEX);        // *
     Serial.print(", регистр 0x");    Serial.print(reg,HEX);        // *
     if( sum>1 ){Serial.print("-0x"); Serial.print(reg+sum-1,HEX);} // *
//   Выполняем запись данных в регистры:                            //
     Wire.beginTransmission(adr);                                   //   Инициируем передачу данных по шине I2C к устройству с адресом adr. При этом сама передача не начнётся.
     Wire.write(reg);                                               //   Помещаем в буфер для передачи один байт (адрес первого регистра для записи).
     Wire.write(arr,sum);                                           //   Помещаем в буфер для передачи sum байт данных из массива arr (данные для записи).
     uint8_t i = Wire.endTransmission();                            //   Выполняем инициированную ранее передачу данных. Функция возвращает: 0-успех или 1-5 ошибка (см. ниже).
//   Информируем о результате записи данных в регистры:             //
     if( i==0 ){                                                    //
         Serial.println( F(" данные успешно записаны! ") );         //
     }else{                                                         //
         Serial.print( F(" ОШИБКА ЗАПИСИ ДАННЫХ: ") );              //
         if( i==1 ){ Serial.println(F("переполнен буфер"      )); } //   Объем буфера по умолчанию 32 байта. Можно изменить в файле iarduino_I2C_Software.h: #define SOFT_I2C_BUFFER_LENGTH 32
         if( i==2 ){ Serial.println(F("NACK на адреса модуля" )); } //   Модуль не ответил на свой адрес, значит модуля с указанным адресом нет на шине I2C.
         if( i==3 ){ Serial.println(F("NACK на адрес регистра")); } //   Модуль не ответил на получение байта, значит модуль занят, регистр недоступен, модуль завис или на шине помехи.
         if( i==4 ){ Serial.println(F("неизвестная ошибка"    )); } //
         if( i==5 ){ Serial.println(F("timeout ожидания"      )); } //   Модуль удерживает шину дольше чем указано в setWireTimeout(), по умолчанию 25'000 мкс.
         Serial.println('.');                                       //
     }                                                              //
//   Задержка перед новым поиском устройств:                        //
     delay(5000);                                                   // * 
}                                                                   //
